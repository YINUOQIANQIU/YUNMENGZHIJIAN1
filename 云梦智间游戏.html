<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å•è¯çˆ†ç ´æ‰‹ - Word Buster</title>
    <!-- å¼•å…¥ä¸æ—¥è®°ç•Œé¢ç›¸åŒçš„CSSæ¡†æ¶ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#2962FF',
                        secondary: '#1A237E',
                        success: '#10B981',
                        warning: '#F59E0B',
                        error: '#EF4444'
                    },
                    fontFamily: {
                        'sans': ['Poppins', 'sans-serif']
                    }
                }
            }
        }
    </script>
    <style>
        /* åŸºç¡€æ ·å¼ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #F0F7FF 0%, #E3F2FF 100%);
            color: #1A237E;
            overflow: hidden;
            min-height: 100vh;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: inherit;
        }

        .hidden {
            display: none !important;
        }

        /* èœå•æ ·å¼ - ä¸æ—¥è®°ç•Œé¢é£æ ¼ç»Ÿä¸€ */
        .menu-container {
            text-align: center;
            background: white;
            padding: 40px;
            border-radius: 16px;
            box-shadow: 0 8px 25px rgba(41, 98, 255, 0.15);
            border: 1px solid rgba(41, 98, 255, 0.1);
            width: 90%;
            max-width: 500px;
        }

        .menu-container h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2962FF;
            font-weight: 700;
        }

        .menu-container p {
            font-size: 1.1em;
            margin-bottom: 30px;
            color: #666;
        }

        .menu-btn {
            background: #2962FF;
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 8px;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 200px;
            font-family: 'Poppins', sans-serif;
            font-weight: 500;
        }

        .menu-btn:hover {
            background: #1A237E;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(41, 98, 255, 0.3);
        }

        .difficulty-selector {
            margin-top: 20px;
            padding: 15px;
            background: rgba(41, 98, 255, 0.05);
            border-radius: 10px;
        }

        .difficulty-selector label {
            margin-right: 10px;
            color: #1A237E;
            font-weight: 500;
        }

        .difficulty-selector select {
            background: white;
            border: 1px solid rgba(41, 98, 255, 0.2);
            padding: 8px 15px;
            border-radius: 6px;
            font-size: 1em;
            font-family: 'Poppins', sans-serif;
        }

        /* æ¸¸æˆç•Œé¢æ ·å¼ */
        #gameScreen {
            flex-direction: column;
            background: #0f3460; /* ä¿æŒæ¸¸æˆèƒŒæ™¯ä¸å˜ */
        }

        #gameCanvas {
            border: 2px solid #4ECDC4;
            border-radius: 10px;
            background: #0f3460;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #4ECDC4;
            color: white;
        }

        .ui-item {
            margin: 5px 0;
            font-size: 1.1em;
            color: #4ECDC4;
        }

        /* ç­”é¢˜åŒºåŸŸæ ·å¼ */
        #answerContainer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 16px;
            border: 2px solid #2962FF;
            min-width: 500px;
            text-align: center;
            box-shadow: 0 8px 25px rgba(41, 98, 255, 0.15);
        }

        #questionText {
            font-size: 1.3em;
            margin-bottom: 20px;
            color: #1A237E;
            font-weight: 600;
        }

        .answer-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        .answer-btn {
            background: #2962FF;
            color: white;
            border: none;
            padding: 15px;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Poppins', sans-serif;
        }

        .answer-btn:hover {
            background: #1A237E;
            transform: translateY(-2px);
        }

        /* æ¸¸æˆç»“æŸç•Œé¢ */
        .game-over-container {
            text-align: center;
            background: white;
            padding: 40px;
            border-radius: 16px;
            box-shadow: 0 8px 25px rgba(41, 98, 255, 0.15);
            border: 1px solid rgba(41, 98, 255, 0.1);
            width: 90%;
            max-width: 500px;
        }

        .game-over-container h2 {
            font-size: 2.2em;
            color: #2962FF;
            margin-bottom: 20px;
        }

        .final-score, .combo-record {
            font-size: 1.3em;
            margin: 15px 0;
            color: #1A237E;
        }

        .game-over-buttons {
            margin-top: 30px;
        }

        /* æˆå°±ç•Œé¢ */
        .achievements-container {
            background: white;
            padding: 40px;
            border-radius: 16px;
            box-shadow: 0 8px 25px rgba(41, 98, 255, 0.15);
            border: 1px solid rgba(41, 98, 255, 0.1);
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            width: 90%;
        }

        .achievements-list {
            margin: 20px 0;
        }

        .achievement-item {
            background: rgba(41, 98, 255, 0.05);
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            border-left: 4px solid #2962FF;
        }

        .achievement-item.unlocked {
            border-left-color: #10B981;
            background: rgba(16, 185, 129, 0.1);
        }

        .achievement-item.locked {
            border-left-color: #9CA3AF;
            background: rgba(156, 163, 175, 0.1);
            opacity: 0.7;
        }

        .achievement-item h3 {
            color: #1A237E;
            margin-bottom: 5px;
        }

        .achievement-item span {
            float: right;
            font-weight: bold;
        }

        .achievement-item.unlocked span {
            color: #10B981;
        }

        .achievement-item.locked span {
            color: #9CA3AF;
        }

        /* è¯æ±‡ç®¡ç†ç•Œé¢ */
        .vocabulary-container {
            background: white;
            padding: 40px;
            border-radius: 16px;
            box-shadow: 0 8px 25px rgba(41, 98, 255, 0.15);
            border: 1px solid rgba(41, 98, 255, 0.1);
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            width: 90%;
        }

        .vocabulary-stats, .vocabulary-actions {
            margin: 30px 0;
            padding: 20px;
            background: rgba(41, 98, 255, 0.05);
            border-radius: 12px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat-item {
            background: rgba(41, 98, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-label {
            display: block;
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-value {
            display: block;
            font-size: 2em;
            font-weight: bold;
            color: #2962FF;
        }

        .action-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .file-upload-area {
            background: rgba(41, 98, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border: 2px dashed #2962FF;
        }

        .upload-options {
            margin: 15px 0;
        }

        .upload-options label {
            display: block;
            margin: 8px 0;
            cursor: pointer;
            color: #1A237E;
        }

        .operation-result {
            background: rgba(41, 98, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .result-message {
            padding: 10px;
            border-radius: 5px;
            font-weight: bold;
        }

        .result-message.success {
            background: rgba(16, 185, 129, 0.2);
            color: #10B981;
            border: 1px solid #10B981;
        }

        .result-message.error {
            background: rgba(239, 68, 68, 0.2);
            color: #EF4444;
            border: 1px solid #EF4444;
        }

        .result-message.info {
            background: rgba(245, 158, 11, 0.2);
            color: #F59E0B;
            border: 1px solid #F59E0B;
        }

        .vocabulary-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }

        /* å·²å¯¼å…¥æ–‡ä»¶æŸ¥çœ‹æ ·å¼ */
        .imported-files-container {
            background: rgba(41, 98, 255, 0.05);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
        }

        .files-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .files-list-container {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 10px;
            overflow: hidden;
        }

        .files-header {
            display: grid;
            grid-template-columns: 40px 2fr 1fr 1fr 1fr 1fr;
            gap: 10px;
            padding: 12px 15px;
            background: rgba(41, 98, 255, 0.1);
            font-weight: bold;
            border-bottom: 1px solid rgba(41, 98, 255, 0.2);
            color: #1A237E;
        }

        .files-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .file-item {
            display: grid;
            grid-template-columns: 40px 2fr 1fr 1fr 1fr 1fr;
            gap: 10px;
            padding: 12px 15px;
            border-bottom: 1px solid rgba(41, 98, 255, 0.1);
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .file-item:hover {
            background: rgba(41, 98, 255, 0.05);
        }

        .file-item.selected {
            background: rgba(41, 98, 255, 0.1);
            border-left: 3px solid #2962FF;
        }

        .file-checkbox {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .file-checkbox input {
            cursor: pointer;
        }

        .file-name {
            font-weight: 500;
            word-break: break-all;
            color: #1A237E;
        }

        .file-size, .file-date, .file-words {
            color: #666;
            font-size: 0.9em;
        }

        .file-status {
            font-size: 0.8em;
            padding: 2px 8px;
            border-radius: 10px;
            text-align: center;
        }

        .status-success {
            background: rgba(16, 185, 129, 0.2);
            color: #10B981;
        }

        .status-warning {
            background: rgba(245, 158, 11, 0.2);
            color: #F59E0B;
        }

        .status-error {
            background: rgba(239, 68, 68, 0.2);
            color: #EF4444;
        }

        .no-files {
            text-align: center;
            padding: 40px;
            color: #666;
            font-style: italic;
        }

        /* æ¨¡æ€æ¡†æ ·å¼ */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(4px);
        }

        .modal-content {
            background: white;
            border-radius: 16px;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(41, 98, 255, 0.2);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid rgba(41, 98, 255, 0.1);
            background: linear-gradient(to right, #2962FF, #1A237E);
            color: white;
            border-radius: 16px 16px 0 0;
        }

        .modal-header h3 {
            margin: 0;
            color: white;
        }

        .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 1.5em;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .modal-body {
            padding: 20px;
            flex: 1;
            overflow-y: auto;
        }

        .modal-footer {
            padding: 15px 20px;
            border-top: 1px solid rgba(41, 98, 255, 0.1);
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .file-info {
            margin-bottom: 20px;
        }

        .info-row {
            display: flex;
            margin-bottom: 10px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(41, 98, 255, 0.05);
        }

        .info-label {
            font-weight: bold;
            width: 120px;
            color: #2962FF;
        }

        .info-value {
            flex: 1;
            word-break: break-all;
            color: #1A237E;
        }

        .file-preview h4 {
            margin-bottom: 10px;
            color: #1A237E;
        }

        .preview-content {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.9em;
            white-space: pre-wrap;
            word-break: break-all;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .menu-container, .game-over-container, 
            .achievements-container, .vocabulary-container {
                margin: 20px;
                padding: 20px;
            }
            
            .menu-container h1 {
                font-size: 2em;
            }
            
            #answerContainer {
                min-width: 90%;
                margin: 10px;
            }
            
            .answer-buttons {
                grid-template-columns: 1fr;
            }
            
            .stats-grid, .action-buttons {
                grid-template-columns: 1fr;
            }
            
            .files-header, .file-item {
                grid-template-columns: 30px 1fr;
                gap: 5px;
            }
            
            .file-size, .file-date, .file-words, .file-status {
                display: none;
            }
            
            .modal-content {
                width: 95%;
                margin: 10px;
            }
            
            .modal-footer {
                flex-direction: column;
            }
        }

        /* æ»šåŠ¨æ¡æ ·å¼ */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(41, 98, 255, 0.1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: #2962FF;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #1A237E;
        }

        /* æ·»åŠ åŠ¨ç”»æ•ˆæœ */
        .fade-in {
            animation: fadeIn 0.3s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>
    <!-- ä¸»èœå•ç•Œé¢ -->
    <div id="menuScreen" class="screen">
        <div class="menu-container fade-in">
            <h1>å•è¯çˆ†ç ´æ‰‹</h1>
            <p>ç”¨çŸ¥è¯†å‡»è´¥é”™è¯¯ï¼Œç”¨æ™ºæ…§å®ˆæŠ¤è¯­æ³•ï¼</p>
            <button id="startButton" class="menu-btn">å¼€å§‹æ¸¸æˆ</button>
            <button id="viewAchievements" class="menu-btn">æˆ‘çš„æˆå°±</button>
            <button id="vocabularyManager" class="menu-btn">è¯æ±‡ç®¡ç†</button>
            <div class="difficulty-selector">
                <label>éš¾åº¦ï¼š</label>
                <select id="difficultySelect">
                    <option value="easy">ç®€å•</option>
                    <option value="medium" selected>ä¸­ç­‰</option>
                    <option value="hard">å›°éš¾</option>
                </select>
            </div>
            <!-- æ·»åŠ è°ƒè¯•æŒ‰é’® -->
            <button id="debugButton" class="menu-btn" style="background: #666; margin-top: 20px;">è°ƒè¯•ä¿¡æ¯</button>
            <!-- æ·»åŠ è¿”å›é¦–é¡µæŒ‰é’® -->
            <button id="backToHome" class="menu-btn" style="background: #F59E0B; margin-top: 10px;">è¿”å›é¦–é¡µ</button>
        </div>
    </div>

    <!-- æ¸¸æˆè¿›è¡Œç•Œé¢ -->
    <div id="gameScreen" class="screen hidden">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="ui">
            <div class="ui-item">å¾—åˆ†: <span id="score">0</span></div>
            <div class="ui-item">è¿å‡»: <span id="combo">0</span></div>
            <div class="ui-item">ç”Ÿå‘½: <span id="lives">3</span></div>
            <div class="ui-item">å…³å¡: <span id="level">1</span></div>
            <div class="ui-item">æ—¶é—´: <span id="timer">60</span>s</div>
        </div>
        
        <!-- ç­”é¢˜é€‰é¡¹åŒºåŸŸ -->
        <div id="answerContainer" class="hidden">
            <p id="questionText"></p>
            <div id="answerButtons" class="answer-buttons"></div>
        </div>
    </div>

    <!-- æ¸¸æˆç»“æŸç•Œé¢ -->
    <div id="gameOverScreen" class="screen hidden">
        <div class="game-over-container fade-in">
            <h2>æ¸¸æˆç»“æŸ!</h2>
            <p class="final-score">ä½ çš„æœ€ç»ˆå¾—åˆ†: <span id="finalScore">0</span></p>
            <p class="combo-record">æœ€é«˜è¿å‡»: <span id="maxCombo">0</span></p>
            <div class="game-over-buttons">
                <button id="restartButton" class="menu-btn">å†ç©ä¸€æ¬¡</button>
                <button id="menuButton" class="menu-btn">è¿”å›ä¸»èœå•</button>
                <button id="resetDataButton" class="menu-btn" style="background: #EF4444;">é‡ç½®æ•°æ®</button>
            </div>
        </div>
    </div>

    <!-- æˆå°±ç•Œé¢ -->
    <div id="achievementsScreen" class="screen hidden">
        <div class="achievements-container fade-in">
            <h2>æˆ‘çš„æˆå°±</h2>
            <div id="achievementsList" class="achievements-list"></div>
            <button id="backToMenu" class="menu-btn">è¿”å›ä¸»èœå•</button>
        </div>
    </div>

    <!-- è¯æ±‡ç®¡ç†ç•Œé¢ -->
    <div id="vocabularyScreen" class="screen hidden">
        <div class="vocabulary-container fade-in">
            <h2>è¯æ±‡ç®¡ç†ç³»ç»Ÿ</h2>
            
            <div class="vocabulary-stats">
                <h3>è¯æ±‡ç»Ÿè®¡</h3>
                <div id="vocabularyStats" class="stats-grid">
                    <div class="stat-item">
                        <span class="stat-label">æ€»è¯æ±‡é‡:</span>
                        <span id="totalWords" class="stat-value">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">CET-4è¯æ±‡:</span>
                        <span id="cet4Words" class="stat-value">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">CET-6è¯æ±‡:</span>
                        <span id="cet6Words" class="stat-value">0</span>
                    </div>
                </div>
            </div>

            <div class="vocabulary-actions">
                <h3>æ•°æ®ç®¡ç†</h3>
                <div class="action-buttons">
                    <button id="importVocabulary" class="menu-btn">å¯¼å…¥è¯æ±‡JSON</button>
                    <button id="exportVocabulary" class="menu-btn">å¯¼å‡ºè¯æ±‡æ•°æ®</button>
                    <button id="generateSample" class="menu-btn">ç”Ÿæˆç¤ºä¾‹æ•°æ®</button>
                    <button id="checkIntegrity" class="menu-btn">æ£€æŸ¥æ•°æ®å®Œæ•´æ€§</button>
                    <button id="cleanupData" class="menu-btn" style="background: #EF4444;">æ¸…ç†æ‰€æœ‰æ•°æ®</button>
                </div>
            </div>

            <!-- å·²å¯¼å…¥æ–‡ä»¶æŸ¥çœ‹åŒºåŸŸ -->
            <div class="imported-files-container">
                <h3>å·²å¯¼å…¥æ–‡ä»¶</h3>
                <div class="files-actions">
                    <button id="refreshFiles" class="menu-btn">åˆ·æ–°æ–‡ä»¶åˆ—è¡¨</button>
                    <button id="viewFileDetails" class="menu-btn" disabled>æŸ¥çœ‹æ–‡ä»¶è¯¦æƒ…</button>
                    <button id="deleteSelectedFile" class="menu-btn" style="background: #EF4444;" disabled>åˆ é™¤é€‰ä¸­æ–‡ä»¶</button>
                </div>
                
                <div class="files-list-container">
                    <div class="files-header">
                        <span class="file-checkbox"><input type="checkbox" id="selectAllFiles"></span>
                        <span class="file-name">æ–‡ä»¶å</span>
                        <span class="file-size">å¤§å°</span>
                        <span class="file-date">å¯¼å…¥æ—¶é—´</span>
                        <span class="file-words">è¯æ±‡æ•°é‡</span>
                        <span class="file-status">çŠ¶æ€</span>
                    </div>
                    <div id="filesList" class="files-list">
                        <!-- æ–‡ä»¶åˆ—è¡¨å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                        <div class="no-files">æš‚æ— å·²å¯¼å…¥çš„æ–‡ä»¶</div>
                    </div>
                </div>
                
                <!-- æ–‡ä»¶è¯¦æƒ…æ¨¡æ€æ¡† -->
                <div id="fileDetailsModal" class="modal hidden">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>æ–‡ä»¶è¯¦æƒ…</h3>
                            <button id="closeFileDetails" class="close-btn">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="file-info">
                                <div class="info-row">
                                    <span class="info-label">æ–‡ä»¶å:</span>
                                    <span id="detailFileName" class="info-value"></span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">æ–‡ä»¶å¤§å°:</span>
                                    <span id="detailFileSize" class="info-value"></span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">å¯¼å…¥æ—¶é—´:</span>
                                    <span id="detailImportTime" class="info-value"></span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">è¯æ±‡æ•°é‡:</span>
                                    <span id="detailWordCount" class="info-value"></span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">æ–‡ä»¶è·¯å¾„:</span>
                                    <span id="detailFilePath" class="info-value"></span>
                                </div>
                            </div>
                            
                            <div class="file-preview">
                                <h4>æ–‡ä»¶å†…å®¹é¢„è§ˆ</h4>
                                <div id="filePreview" class="preview-content">
                                    <!-- æ–‡ä»¶å†…å®¹é¢„è§ˆå°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button id="exportSelectedFile" class="menu-btn">å¯¼å‡ºæ­¤æ–‡ä»¶</button>
                            <button id="closeModal" class="menu-btn" style="background: #666;">å…³é—­</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ä¿®å¤ï¼šæ–‡ä»¶ä¸Šä¼ åŒºåŸŸï¼Œæ·»åŠ æ‹–æ”¾åŠŸèƒ½ -->
            <div class="file-upload-area" id="fileUploadArea" style="display: none;">
                <h4>ä¸Šä¼ è¯æ±‡æ–‡ä»¶</h4>
                
                <!-- ä¿®å¤ï¼šæ·»åŠ æ‹–æ”¾åŒºåŸŸå’Œæ–‡ä»¶åˆ—è¡¨æ˜¾ç¤º -->
                <div class="upload-drop-zone" id="uploadDropZone" 
                     style="border: 2px dashed #2962FF; padding: 40px; text-align: center; border-radius: 10px; margin-bottom: 20px; cursor: pointer;">
                    <p>ğŸ“ ç‚¹å‡»é€‰æ‹©æ–‡ä»¶æˆ–æ‹–æ”¾æ–‡ä»¶åˆ°è¿™é‡Œ</p>
                    <p style="font-size: 0.9em; opacity: 0.7;">æ”¯æŒå¤šä¸ªJSONæ–‡ä»¶åŒæ—¶ä¸Šä¼ </p>
                </div>
                
                <input type="file" id="vocabularyFile" accept=".json" multiple style="display: none;">
                
                <!-- ä¿®å¤ï¼šæ˜¾ç¤ºé€‰ä¸­çš„æ–‡ä»¶åˆ—è¡¨ -->
                <div id="selectedFiles" style="margin: 15px 0; display: none;">
                    <h5>å·²é€‰æ‹©çš„æ–‡ä»¶:</h5>
                    <div id="fileList" style="max-height: 200px; overflow-y: auto; background: rgba(41,98,255,0.05); padding: 10px; border-radius: 5px;"></div>
                </div>
                
                <div class="upload-options">
                    <label>
                        <input type="radio" name="importMode" value="update" checked> æ›´æ–°ç°æœ‰è¯æ±‡
                    </label>
                    <label>
                        <input type="radio" name="importMode" value="skip"> è·³è¿‡ç°æœ‰è¯æ±‡
                    </label>
                </div>
                <button id="confirmImport" class="menu-btn">ç¡®è®¤å¯¼å…¥</button>
                <button id="cancelImport" class="menu-btn" style="background: #666;">å–æ¶ˆ</button>
            </div>

            <div class="operation-result" id="operationResult" style="display: none;">
                <h4>æ“ä½œç»“æœ</h4>
                <div id="resultMessage" class="result-message"></div>
            </div>

            <div class="vocabulary-buttons">
                <button id="backToMenuFromVocab" class="menu-btn">è¿”å›ä¸»èœå•</button>
                <button id="refreshStats" class="menu-btn">åˆ·æ–°ç»Ÿè®¡</button>
            </div>
        </div>
    </div>

    <script>
        // åŠ¨æ€è·å–æœåŠ¡å™¨åœ°å€ - ä¿®æ”¹ä¸ºç›¸å¯¹è·¯å¾„
        const baseURL = '';
        window.gameBaseURL = baseURL;

        // é¡µé¢åŠ è½½å®Œæˆåçš„åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            console.log('ä½¿ç”¨ç›¸å¯¹è·¯å¾„APIè°ƒç”¨');
            
            // æ·»åŠ è¿”å›é¦–é¡µæŒ‰é’®äº‹ä»¶å¤„ç†
            const backToHomeBtn = document.getElementById('backToHome');
            if (backToHomeBtn) {
                backToHomeBtn.addEventListener('click', function() {
                    // è·³è½¬åˆ°äº‘æ¢¦æ™ºé—´é¦–é¡µ
                    window.location.href = 'äº‘æ¢¦æ™ºé—´é¦–é¡µ.html';
                });
            }
            
            // è¯æ±‡ç®¡ç†æŒ‰é’®
            const vocabManagerBtn = document.getElementById('vocabularyManager');
            const vocabScreen = document.getElementById('vocabularyScreen');
            const backToMenuFromVocabBtn = document.getElementById('backToMenuFromVocab');
            
            if (vocabManagerBtn && vocabScreen && backToMenuFromVocabBtn) {
                vocabManagerBtn.addEventListener('click', function() {
                    document.querySelectorAll('.screen').forEach(screen => {
                        screen.classList.add('hidden');
                    });
                    vocabScreen.classList.remove('hidden');
                    loadVocabularyStats();
                    initFileManagement(); // åˆå§‹åŒ–æ–‡ä»¶ç®¡ç†
                });
                
                backToMenuFromVocabBtn.addEventListener('click', function() {
                    document.querySelectorAll('.screen').forEach(screen => {
                        screen.classList.add('hidden');
                    });
                    document.getElementById('menuScreen').classList.remove('hidden');
                });
            }
            
            // è¯æ±‡ç®¡ç†åŠŸèƒ½
            const importVocabBtn = document.getElementById('importVocabulary');
            const exportVocabBtn = document.getElementById('exportVocabulary');
            const generateSampleBtn = document.getElementById('generateSample');
            const checkIntegrityBtn = document.getElementById('checkIntegrity');
            const cleanupDataBtn = document.getElementById('cleanupData');
            const refreshStatsBtn = document.getElementById('refreshStats');
            const fileUploadArea = document.getElementById('fileUploadArea');
            const confirmImportBtn = document.getElementById('confirmImport');
            const cancelImportBtn = document.getElementById('cancelImport');
            const operationResult = document.getElementById('operationResult');
            const resultMessage = document.getElementById('resultMessage');
            
            // å¯¼å…¥è¯æ±‡
            if (importVocabBtn) {
                importVocabBtn.addEventListener('click', function() {
                    fileUploadArea.style.display = 'block';
                    operationResult.style.display = 'none';
                });
            }
            
            // ä¿®å¤ï¼šæ–‡ä»¶é€‰æ‹©å’Œæ‹–æ”¾åŠŸèƒ½
            const uploadDropZone = document.getElementById('uploadDropZone');
            const vocabularyFile = document.getElementById('vocabularyFile');
            const selectedFiles = document.getElementById('selectedFiles');
            const fileList = document.getElementById('fileList');

            // ç‚¹å‡»æ‹–æ”¾åŒºåŸŸè§¦å‘æ–‡ä»¶é€‰æ‹©
            if (uploadDropZone) {
                uploadDropZone.addEventListener('click', () => {
                    vocabularyFile.click();
                });
            }

            // æ–‡ä»¶é€‰æ‹©å˜åŒ–äº‹ä»¶
            if (vocabularyFile) {
                vocabularyFile.addEventListener('change', function(e) {
                    updateFileList(this.files);
                });
            }

            // æ‹–æ”¾åŠŸèƒ½
            if (uploadDropZone) {
                // é˜²æ­¢é»˜è®¤æ‹–æ”¾è¡Œä¸º
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    uploadDropZone.addEventListener(eventName, preventDefaults, false);
                    document.body.addEventListener(eventName, preventDefaults, false);
                });
                
                // é«˜äº®æ‹–æ”¾åŒºåŸŸ
                ['dragenter', 'dragover'].forEach(eventName => {
                    uploadDropZone.addEventListener(eventName, highlight, false);
                });
                
                ['dragleave', 'drop'].forEach(eventName => {
                    uploadDropZone.addEventListener(eventName, unhighlight, false);
                });
                
                // å¤„ç†æ–‡ä»¶æ‹–æ”¾
                uploadDropZone.addEventListener('drop', handleDrop, false);
            }

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            function highlight() {
                uploadDropZone.style.backgroundColor = 'rgba(41, 98, 255, 0.1)';
                uploadDropZone.style.borderColor = '#F59E0B';
            }

            function unhighlight() {
                uploadDropZone.style.backgroundColor = '';
                uploadDropZone.style.borderColor = '#2962FF';
            }

            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                vocabularyFile.files = files;
                updateFileList(files);
            }

            // æ›´æ–°æ–‡ä»¶åˆ—è¡¨æ˜¾ç¤º
            function updateFileList(files) {
                if (!files || files.length === 0) {
                    selectedFiles.style.display = 'none';
                    fileList.innerHTML = '';
                    return;
                }
                
                fileList.innerHTML = '';
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const fileItem = document.createElement('div');
                    fileItem.style.padding = '8px';
                    fileItem.style.borderBottom = '1px solid rgba(41,98,255,0.1)';
                    fileItem.style.display = 'flex';
                    fileItem.style.justifyContent = 'space-between';
                    fileItem.style.alignItems = 'center';
                    
                    fileItem.innerHTML = `
                        <div>
                            <span style="font-weight: bold;">${file.name}</span>
                            <span style="font-size: 0.8em; opacity: 0.7; margin-left: 10px;">
                                (${(file.size / 1024).toFixed(2)} KB)
                            </span>
                        </div>
                        <span style="color: #2962FF;">âœ“</span>
                    `;
                    
                    fileList.appendChild(fileItem);
                }
                
                selectedFiles.style.display = 'block';
            }
            
            // ä¿®å¤ï¼šç¡®è®¤å¯¼å…¥æŒ‰é’®äº‹ä»¶å¤„ç†
            if (confirmImportBtn) {
                confirmImportBtn.addEventListener('click', async function() {
                    const files = vocabularyFile.files;
                    const importMode = document.querySelector('input[name="importMode"]:checked').value;
                    
                    if (files.length === 0) {
                        showResult('è¯·é€‰æ‹©è¦å¯¼å…¥çš„æ–‡ä»¶', 'error');
                        return;
                    }
                    
                    try {
                        showResult('æ­£åœ¨å¯¼å…¥è¯æ±‡æ•°æ®...', 'info');
                        
                        const formData = new FormData();
                        for (let i = 0; i < files.length; i++) {
                            formData.append('files', files[i]);
                        }
                        formData.append('mode', importMode);
                        
                        // ä¿®æ”¹APIè·¯å¾„ - ä½¿ç”¨ç›¸å¯¹è·¯å¾„
                        const response = await fetch(`/api/game/vocabulary/import-vocabulary-multiple`, {
                            method: 'POST',
                            body: formData
                        });
                        
                        const result = await response.json();
                        
                        if (result.success) {
                            showResult(result.message, 'success');
                            loadVocabularyStats();
                            loadImportedFiles(); // åˆ·æ–°æ–‡ä»¶åˆ—è¡¨
                            
                            // æ¸…ç©ºæ–‡ä»¶é€‰æ‹©
                            vocabularyFile.value = '';
                            selectedFiles.style.display = 'none';
                            fileList.innerHTML = '';
                        } else {
                            showResult(`å¯¼å…¥å¤±è´¥: ${result.message}`, 'error');
                        }
                    } catch (error) {
                        showResult(`å¯¼å…¥é”™è¯¯: ${error.message}`, 'error');
                    }
                });
            }
            
            // å–æ¶ˆå¯¼å…¥
            if (cancelImportBtn) {
                cancelImportBtn.addEventListener('click', function() {
                    fileUploadArea.style.display = 'none';
                    vocabularyFile.value = '';
                    selectedFiles.style.display = 'none';
                    fileList.innerHTML = '';
                });
            }
            
            // å¯¼å‡ºè¯æ±‡
            if (exportVocabBtn) {
                exportVocabBtn.addEventListener('click', function() {
                    // ç›´æ¥æ‰“å¼€ä¸‹è½½é“¾æ¥
                    const downloadLink = document.createElement('a');
                    // ä¿®æ”¹APIè·¯å¾„ - ä½¿ç”¨ç›¸å¯¹è·¯å¾„
                    downloadLink.href = `/api/game/vocabulary/export-vocabulary-json`;
                    downloadLink.download = 'vocabulary-export.json';
                    downloadLink.click();
                });
            }
            
            // ç”Ÿæˆç¤ºä¾‹æ•°æ®
            if (generateSampleBtn) {
                generateSampleBtn.addEventListener('click', async function() {
                    try {
                        showResult('æ­£åœ¨ç”Ÿæˆç¤ºä¾‹æ•°æ®...', 'info');
                        
                        // ä¿®æ”¹APIè·¯å¾„ - ä½¿ç”¨ç›¸å¯¹è·¯å¾„
                        const response = await fetch(`/api/game/vocabulary/generate-vocabulary-sample`, {
                            method: 'POST'
                        });
                        
                        const result = await response.json();
                        
                        if (result.success) {
                            showResult('ç¤ºä¾‹æ•°æ®ç”ŸæˆæˆåŠŸï¼Œæ–‡ä»¶å·²ä¿å­˜åˆ°æœåŠ¡å™¨', 'success');
                            loadVocabularyStats();
                            loadImportedFiles(); // åˆ·æ–°æ–‡ä»¶åˆ—è¡¨
                        } else {
                            showResult(`ç”Ÿæˆå¤±è´¥: ${result.message}`, 'error');
                        }
                    } catch (error) {
                        showResult(`ç”Ÿæˆé”™è¯¯: ${error.message}`, 'error');
                    }
                });
            }
            
            // æ£€æŸ¥æ•°æ®å®Œæ•´æ€§
            if (checkIntegrityBtn) {
                checkIntegrityBtn.addEventListener('click', async function() {
                    try {
                        showResult('æ­£åœ¨æ£€æŸ¥æ•°æ®å®Œæ•´æ€§...', 'info');
                        
                        // ä¿®æ”¹APIè·¯å¾„ - ä½¿ç”¨ç›¸å¯¹è·¯å¾„
                        const response = await fetch(`/api/game/vocabulary/check-vocabulary-integrity`);
                        const result = await response.json();
                        
                        if (result.success) {
                            const data = result.data;
                            showResult(`æ•°æ®å®Œæ•´æ€§æ£€æŸ¥å®Œæˆ: æ€»è¯æ±‡ ${data.total_words}ï¼Œæœ‰æ•ˆè¯æ±‡ ${data.valid_words}ï¼Œæ— æ•ˆè¯æ±‡ ${data.invalid_words}`, 'success');
                        } else {
                            showResult(`æ£€æŸ¥å¤±è´¥: ${result.message}`, 'error');
                        }
                    } catch (error) {
                        showResult(`æ£€æŸ¥é”™è¯¯: ${error.message}`, 'error');
                    }
                });
            }
            
            // æ¸…ç†æ•°æ®
            if (cleanupDataBtn) {
                cleanupDataBtn.addEventListener('click', function() {
                    if (confirm('ç¡®å®šè¦æ¸…ç†æ‰€æœ‰è¯æ±‡æ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯é€†ï¼')) {
                        cleanupVocabularyData();
                    }
                });
            }
            
            // åˆ·æ–°ç»Ÿè®¡
            if (refreshStatsBtn) {
                refreshStatsBtn.addEventListener('click', loadVocabularyStats);
            }
            
            // åŠ è½½è¯æ±‡ç»Ÿè®¡
            async function loadVocabularyStats() {
                try {
                    // ä¿®æ”¹APIè·¯å¾„ - ä½¿ç”¨ç›¸å¯¹è·¯å¾„
                    const response = await fetch(`/api/game/vocabulary/vocabulary-statistics`);
                    const result = await response.json();
                    
                    if (result.success) {
                        const stats = result.data;
                        const totalWords = stats.total_words?.[0]?.count || 0;
                        const wordsByLevel = stats.words_by_level || [];
                        
                        document.getElementById('totalWords').textContent = totalWords;
                        
                        const cet4Count = wordsByLevel.find(item => item.level === 'CET-4')?.count || 0;
                        const cet6Count = wordsByLevel.find(item => item.level === 'CET-6')?.count || 0;
                        
                        document.getElementById('cet4Words').textContent = cet4Count;
                        document.getElementById('cet6Words').textContent = cet6Count;
                    }
                } catch (error) {
                    console.error('åŠ è½½è¯æ±‡ç»Ÿè®¡å¤±è´¥:', error);
                    showResult('åŠ è½½è¯æ±‡ç»Ÿè®¡å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨è¿æ¥', 'error');
                }
            }
            
            // æ¸…ç†è¯æ±‡æ•°æ®
            async function cleanupVocabularyData() {
                try {
                    showResult('æ­£åœ¨æ¸…ç†æ•°æ®...', 'info');
                    
                    // ä¿®æ”¹APIè·¯å¾„ - ä½¿ç”¨ç›¸å¯¹è·¯å¾„
                    const response = await fetch(`/api/game/vocabulary/cleanup-vocabulary-data`, {
                        method: 'POST'
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        showResult('æ•°æ®æ¸…ç†å®Œæˆ', 'success');
                        loadVocabularyStats();
                    } else {
                        showResult(`æ¸…ç†å¤±è´¥: ${result.message}`, 'error');
                    }
                } catch (error) {
                    showResult(`æ¸…ç†é”™è¯¯: ${error.message}`, 'error');
                }
            }
            
            // æ˜¾ç¤ºæ“ä½œç»“æœ
            function showResult(message, type) {
                operationResult.style.display = 'block';
                resultMessage.textContent = message;
                resultMessage.className = 'result-message ' + type;
                
                // 3ç§’åè‡ªåŠ¨éšè—æˆåŠŸæ¶ˆæ¯
                if (type === 'success') {
                    setTimeout(() => {
                        operationResult.style.display = 'none';
                    }, 3000);
                }
            }
            
            // æ–‡ä»¶ç®¡ç†åŠŸèƒ½
            let selectedFile = null;
            let allFiles = [];

            // åˆå§‹åŒ–æ–‡ä»¶ç®¡ç†äº‹ä»¶
            function initFileManagement() {
                const refreshFilesBtn = document.getElementById('refreshFiles');
                const viewFileDetailsBtn = document.getElementById('viewFileDetails');
                const deleteSelectedFileBtn = document.getElementById('deleteSelectedFile');
                const selectAllFilesCheckbox = document.getElementById('selectAllFiles');
                const closeFileDetailsBtn = document.getElementById('closeFileDetails');
                const closeModalBtn = document.getElementById('closeModal');
                const exportSelectedFileBtn = document.getElementById('exportSelectedFile');
                
                if (refreshFilesBtn) {
                    refreshFilesBtn.addEventListener('click', loadImportedFiles);
                }
                
                if (viewFileDetailsBtn) {
                    viewFileDetailsBtn.addEventListener('click', viewFileDetails);
                }
                
                if (deleteSelectedFileBtn) {
                    deleteSelectedFileBtn.addEventListener('click', deleteSelectedFile);
                }
                
                if (selectAllFilesCheckbox) {
                    selectAllFilesCheckbox.addEventListener('change', toggleSelectAllFiles);
                }
                
                if (closeFileDetailsBtn) {
                    closeFileDetailsBtn.addEventListener('click', closeFileDetailsModal);
                }
                
                if (closeModalBtn) {
                    closeModalBtn.addEventListener('click', closeFileDetailsModal);
                }
                
                if (exportSelectedFileBtn) {
                    exportSelectedFileBtn.addEventListener('click', exportSelectedFile);
                }
                
                // åˆå§‹åŠ è½½æ–‡ä»¶åˆ—è¡¨
                loadImportedFiles();
            }

            // åŠ è½½å·²å¯¼å…¥çš„æ–‡ä»¶
            async function loadImportedFiles() {
                try {
                    // ä¿®æ”¹APIè·¯å¾„ - ä½¿ç”¨ç›¸å¯¹è·¯å¾„
                    const response = await fetch(`/api/game/vocabulary/get-imported-files`);
                    const result = await response.json();
                    
                    if (result.success) {
                        allFiles = result.files;
                        displayFilesList(allFiles);
                    } else {
                        showResult(`åŠ è½½æ–‡ä»¶åˆ—è¡¨å¤±è´¥: ${result.message}`, 'error');
                    }
                } catch (error) {
                    showResult(`åŠ è½½æ–‡ä»¶åˆ—è¡¨å¤±è´¥: ${error.message}`, 'error');
                }
            }

            // æ˜¾ç¤ºæ–‡ä»¶åˆ—è¡¨
            function displayFilesList(files) {
                const filesList = document.getElementById('filesList');
                
                if (!filesList) return;
                
                if (files.length === 0) {
                    filesList.innerHTML = '<div class="no-files">æš‚æ— å·²å¯¼å…¥çš„æ–‡ä»¶</div>';
                    return;
                }
                
                filesList.innerHTML = '';
                
                files.forEach((file, index) => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    fileItem.dataset.index = index;
                    
                    const fileSize = formatFileSize(file.size);
                    const modifiedDate = new Date(file.modified).toLocaleString();
                    const wordCount = file.wordCount || 'æœªçŸ¥';
                    
                    fileItem.innerHTML = `
                        <span class="file-checkbox">
                            <input type="checkbox" class="file-checkbox-input" data-file-path="${file.path}">
                        </span>
                        <span class="file-name" title="${file.name}">${file.name}</span>
                        <span class="file-size">${fileSize}</span>
                        <span class="file-date">${modifiedDate}</span>
                        <span class="file-words">${wordCount}</span>
                        <span class="file-status ${getStatusClass(file.status)}">${getStatusText(file.status)}</span>
                    `;
                    
                    // æ·»åŠ ç‚¹å‡»äº‹ä»¶
                    fileItem.addEventListener('click', (e) => {
                        if (!e.target.classList.contains('file-checkbox-input')) {
                            toggleFileSelection(fileItem, file);
                        }
                    });
                    
                    // æ·»åŠ å¤é€‰æ¡†äº‹ä»¶
                    const checkbox = fileItem.querySelector('.file-checkbox-input');
                    checkbox.addEventListener('change', (e) => {
                        e.stopPropagation();
                        toggleFileSelection(fileItem, file);
                    });
                    
                    filesList.appendChild(fileItem);
                });
                
                updateFileActionsState();
            }

            // åˆ‡æ¢æ–‡ä»¶é€‰æ‹©
            function toggleFileSelection(fileItem, file) {
                const wasSelected = fileItem.classList.contains('selected');
                
                // æ¸…é™¤æ‰€æœ‰é€‰æ‹©
                document.querySelectorAll('.file-item').forEach(item => {
                    item.classList.remove('selected');
                });
                document.querySelectorAll('.file-checkbox-input').forEach(checkbox => {
                    checkbox.checked = false;
                });
                
                if (!wasSelected) {
                    fileItem.classList.add('selected');
                    fileItem.querySelector('.file-checkbox-input').checked = true;
                    selectedFile = file;
                } else {
                    selectedFile = null;
                }
                
                updateFileActionsState();
            }

            // åˆ‡æ¢å…¨é€‰
            function toggleSelectAllFiles(e) {
                const checkboxes = document.querySelectorAll('.file-checkbox-input');
                const isChecked = e.target.checked;
                
                checkboxes.forEach(checkbox => {
                    checkbox.checked = isChecked;
                });
                
                document.querySelectorAll('.file-item').forEach(item => {
                    if (isChecked) {
                        item.classList.add('selected');
                    } else {
                        item.classList.remove('selected');
                    }
                });
                
                if (isChecked && allFiles.length > 0) {
                    selectedFile = allFiles[0]; // é€‰æ‹©ç¬¬ä¸€ä¸ªæ–‡ä»¶
                } else {
                    selectedFile = null;
                }
                
                updateFileActionsState();
            }

            // æ›´æ–°æ–‡ä»¶æ“ä½œæŒ‰é’®çŠ¶æ€
            function updateFileActionsState() {
                const viewFileDetailsBtn = document.getElementById('viewFileDetails');
                const deleteSelectedFileBtn = document.getElementById('deleteSelectedFile');
                
                if (viewFileDetailsBtn) {
                    viewFileDetailsBtn.disabled = !selectedFile;
                }
                
                if (deleteSelectedFileBtn) {
                    deleteSelectedFileBtn.disabled = !selectedFile;
                }
            }

            // æŸ¥çœ‹æ–‡ä»¶è¯¦æƒ…
            async function viewFileDetails() {
                if (!selectedFile) return;
                
                try {
                    // ä¿®æ”¹APIè·¯å¾„ - ä½¿ç”¨ç›¸å¯¹è·¯å¾„
                    const response = await fetch(`/api/game/vocabulary/get-file-details?filePath=${encodeURIComponent(selectedFile.path)}`);
                    const result = await response.json();
                    
                    if (result.success) {
                        displayFileDetails(result.data);
                    } else {
                        showResult(`è·å–æ–‡ä»¶è¯¦æƒ…å¤±è´¥: ${result.message}`, 'error');
                    }
                } catch (error) {
                    showResult(`è·å–æ–‡ä»¶è¯¦æƒ…å¤±è´¥: ${error.message}`, 'error');
                }
            }

            // æ˜¾ç¤ºæ–‡ä»¶è¯¦æƒ…
            function displayFileDetails(fileDetails) {
                const modal = document.getElementById('fileDetailsModal');
                const fileName = document.getElementById('detailFileName');
                const fileSize = document.getElementById('detailFileSize');
                const importTime = document.getElementById('detailImportTime');
                const wordCount = document.getElementById('detailWordCount');
                const filePath = document.getElementById('detailFilePath');
                const filePreview = document.getElementById('filePreview');
                
                if (!modal || !fileName) return;
                
                fileName.textContent = fileDetails.name;
                fileSize.textContent = formatFileSize(fileDetails.size);
                importTime.textContent = new Date(fileDetails.modified).toLocaleString();
                wordCount.textContent = fileDetails.wordCount || 'æœªçŸ¥';
                filePath.textContent = fileDetails.path;
                
                // æ˜¾ç¤ºæ–‡ä»¶å†…å®¹é¢„è§ˆ
                try {
                    const jsonContent = JSON.parse(fileDetails.content);
                    filePreview.textContent = JSON.stringify(jsonContent, null, 2);
                } catch (e) {
                    filePreview.textContent = fileDetails.content;
                }
                
                modal.classList.remove('hidden');
            }

            // å…³é—­æ–‡ä»¶è¯¦æƒ…æ¨¡æ€æ¡†
            function closeFileDetailsModal() {
                const modal = document.getElementById('fileDetailsModal');
                if (modal) {
                    modal.classList.add('hidden');
                }
            }

            // åˆ é™¤é€‰ä¸­çš„æ–‡ä»¶
            async function deleteSelectedFile() {
                if (!selectedFile) return;
                
                if (!confirm(`ç¡®å®šè¦åˆ é™¤æ–‡ä»¶ "${selectedFile.name}" å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼`)) {
                    return;
                }
                
                try {
                    // ä¿®æ”¹APIè·¯å¾„ - ä½¿ç”¨ç›¸å¯¹è·¯å¾„
                    const response = await fetch(`/api/game/vocabulary/delete-imported-file`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            fileName: selectedFile.name,
                            filePath: selectedFile.path
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        showResult(result.message, 'success');
                        loadImportedFiles(); // åˆ·æ–°æ–‡ä»¶åˆ—è¡¨
                        selectedFile = null;
                    } else {
                        showResult(`åˆ é™¤æ–‡ä»¶å¤±è´¥: ${result.message}`, 'error');
                    }
                } catch (error) {
                    showResult(`åˆ é™¤æ–‡ä»¶å¤±è´¥: ${error.message}`, 'error');
                }
            }

            // å¯¼å‡ºé€‰ä¸­çš„æ–‡ä»¶
            function exportSelectedFile() {
                if (!selectedFile) return;
                
                const downloadLink = document.createElement('a');
                downloadLink.href = URL.createObjectURL(new Blob([selectedFile.content], { type: 'application/json' }));
                downloadLink.download = selectedFile.name;
                downloadLink.click();
                URL.revokeObjectURL(downloadLink.href);
            }

            // å·¥å…·å‡½æ•°ï¼šæ ¼å¼åŒ–æ–‡ä»¶å¤§å°
            function formatFileSize(bytes) {
                if (bytes === 0) return '0 B';
                
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            // å·¥å…·å‡½æ•°ï¼šè·å–çŠ¶æ€ç±»å
            function getStatusClass(status) {
                switch (status) {
                    case 'uploaded':
                        return 'status-success';
                    case 'exported':
                        return 'status-warning';
                    default:
                        return 'status-error';
                }
            }

            // å·¥å…·å‡½æ•°ï¼šè·å–çŠ¶æ€æ–‡æœ¬
            function getStatusText(status) {
                switch (status) {
                    case 'uploaded':
                        return 'å·²ä¸Šä¼ ';
                    case 'exported':
                        return 'å·²å¯¼å‡º';
                    default:
                        return 'æœªçŸ¥';
                }
            }
            
            // æ·»åŠ è°ƒè¯•æŒ‰é’®åŠŸèƒ½
            const debugButton = document.getElementById('debugButton');
            if (debugButton) {
                debugButton.addEventListener('click', function() {
                    if (window.gameServer) {
                        window.gameServer.debugInfo();
                    } else {
                        console.log('æ¸¸æˆæœåŠ¡å™¨æœªåˆå§‹åŒ–');
                    // å°è¯•ä»å…¨å±€è®¿é—®
                        if (typeof gameServer !== 'undefined') {
                            gameServer.debugInfo();
                        } else {
                            console.log('è¯·å…ˆå¯åŠ¨æœåŠ¡å™¨');
                        }
                    }
                });
            }
            
            // æ·»åŠ é‡ç½®æ•°æ®æŒ‰é’®åŠŸèƒ½
            const resetDataButton = document.getElementById('resetDataButton');
            if (resetDataButton) {
                resetDataButton.addEventListener('click', function() {
                    if (confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰æ¸¸æˆæ•°æ®å—ï¼Ÿè¿™å°†æ¸…é™¤å¾—åˆ†ã€æˆå°±å’Œç»Ÿè®¡ä¿¡æ¯ã€‚')) {
                        // æ¸…é™¤æœ¬åœ°å­˜å‚¨æ•°æ®
                        localStorage.removeItem('wordBusterAchievements');
                        localStorage.removeItem('questionStats');
                        localStorage.removeItem('playerStats');
                        
                        alert('æ¸¸æˆæ•°æ®å·²é‡ç½®');
                        
                        // å¦‚æœæœåŠ¡å™¨å¯ç”¨ï¼Œä¹Ÿé‡ç½®æœåŠ¡å™¨æ•°æ®
                        if (typeof gameServer !== 'undefined') {
                            gameServer.resetGameData();
                        }
                    }
                });
            }
            
            // åˆå§‹åŒ–æ—¶åŠ è½½ç»Ÿè®¡
            loadVocabularyStats();
            
            console.log('ğŸ® å•è¯çˆ†ç ´æ‰‹æ¸¸æˆåŠ è½½å®Œæˆ');
            console.log('ğŸ“š è¯æ±‡ç®¡ç†ç³»ç»Ÿå·²é›†æˆ');
            console.log('ğŸ“ å·²å¯¼å…¥æ–‡ä»¶æŸ¥çœ‹åŠŸèƒ½å·²å¯ç”¨');
            console.log('ğŸ’¡ åœ¨æ§åˆ¶å°è¾“å…¥ gameServer.debugInfo() æŸ¥çœ‹è°ƒè¯•ä¿¡æ¯');
        });
    </script>

    <!-- æ¸¸æˆæ ¸å¿ƒé€»è¾‘ -->
    <script>
        // ç©å®¶ç±»
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 40;
                this.height = 60;
                this.color = '#4ECDC4';
                this.gunColor = '#FF6B6B';
                this.rotation = 0;
                this.targetRotation = 0;
                this.health = 100;
                this.isShooting = false;
                this.shootCooldown = 0;
                this.maxCooldown = 0.2; // å°„å‡»å†·å´æ—¶é—´ï¼ˆç§’ï¼‰
            }

            update(deltaTime) {
                // æ›´æ–°å°„å‡»å†·å´
                if (this.shootCooldown > 0) {
                    this.shootCooldown -= deltaTime;
                }

                // å¹³æ»‘æ—‹è½¬ç‚®å°
                this.rotation += (this.targetRotation - this.rotation) * 0.1;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // ç»˜åˆ¶ç‚®å°åº•åº§
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                
                // ç»˜åˆ¶ç‚®å°ç»†èŠ‚
                ctx.fillStyle = '#45B7AF';
                ctx.fillRect(-this.width / 2 + 5, -this.height / 2 + 5, this.width - 10, 10);
                
                // ç»˜åˆ¶ç‚®ç®¡
                ctx.rotate(this.rotation);
                ctx.fillStyle = this.gunColor;
                ctx.fillRect(-5, -25, 10, 30);
                
                // ç»˜åˆ¶ç‚®å£é—ªå…‰ï¼ˆå°„å‡»æ—¶ï¼‰
                if (this.isShooting) {
                    ctx.fillStyle = '#FFFF00';
                    ctx.fillRect(-3, -35, 6, 10);
                    this.isShooting = false;
                }
                
                ctx.restore();
                
                // ç»˜åˆ¶ç©å®¶ç”Ÿå‘½æ¡
                this.drawHealthBar(ctx);
            }

            drawHealthBar(ctx) {
                const barWidth = 60;
                const barHeight = 6;
                const barX = this.x - barWidth / 2;
                const barY = this.y + this.height / 2 + 10;
                
                // èƒŒæ™¯
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // ç”Ÿå‘½å€¼
                const healthWidth = (this.health / 100) * barWidth;
                ctx.fillStyle = this.getHealthColor();
                ctx.fillRect(barX, barY, healthWidth, barHeight);
                
                // è¾¹æ¡†
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 1;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
            }

            getHealthColor() {
                if (this.health > 70) return '#4ECDC4';
                if (this.health > 30) return '#FFE66D';
                return '#FF6B6B';
            }

            setTargetRotation(angle) {
                this.targetRotation = angle;
            }

            shoot() {
                if (this.shootCooldown <= 0) {
                    this.isShooting = true;
                    this.shootCooldown = this.maxCooldown;
                    return true;
                }
                return false;
            }

            takeDamage(amount) {
                this.health = Math.max(0, this.health - amount);
                return this.health <= 0;
            }

            heal(amount) {
                this.health = Math.min(100, this.health + amount);
            }
        }

        // æ•Œäººç±»
        class Enemy {
            constructor(question) {
                this.question = question;
                this.type = question.type;
                this.radius = 25;
                this.x = Math.random() * (800 - this.radius * 2) + this.radius;
                this.y = -this.radius;
                this.speed = this.getBaseSpeed();
                this.color = this.getColorByType();
                this.hitPoints = 1;
                this.maxHitPoints = 1;
                this.isActive = true;
                this.waveOffset = Math.random() * Math.PI * 2;
                this.waveSpeed = Math.random() * 2 + 1;
                this.waveAmplitude = Math.random() * 20 + 10;
                this.startX = this.x;
                
                // ç‰¹æ®Šæ•ˆæœ
                this.effectTimer = 0;
                this.isFlashing = false;
            }

            getBaseSpeed() {
                const baseSpeeds = {
                    'spelling': 1.5,
                    'fillBlank': 2.0,
                    'synonym': 1.8,
                    'grammar': 1.2
                };
                return baseSpeeds[this.type] || 2.0;
            }

            getColorByType() {
                const colors = {
                    'spelling': '#FF6B6B',    // çº¢è‰² - æ‹¼å†™é”™è¯¯
                    'fillBlank': '#4ECDC4',   // é’è‰² - å¡«ç©º
                    'synonym': '#FFE66D',     // é»„è‰² - åŒä¹‰è¯
                    'grammar': '#6A0572'      // ç´«è‰² - è¯­æ³•
                };
                return colors[this.type] || '#95E1D3';
            }

            update(deltaTime) {
                // åŸºç¡€ç§»åŠ¨
                this.y += this.speed;
                
                // æ³¢æµªç§»åŠ¨
                this.x = this.startX + Math.sin(this.waveOffset + this.y * 0.01 * this.waveSpeed) * this.waveAmplitude;
                
                // æ›´æ–°ç‰¹æ•ˆè®¡æ—¶å™¨
                if (this.effectTimer > 0) {
                    this.effectTimer -= deltaTime;
                    this.isFlashing = this.effectTimer > 0 && Math.floor(this.effectTimer * 10) % 2 === 0;
                }
                
                // å±å¹•è¾¹ç•Œæ£€æŸ¥
                if (this.x < this.radius) this.x = this.radius;
                if (this.x > 800 - this.radius) this.x = 800 - this.radius;
            }

            draw(ctx) {
                ctx.save();
                
                // ç»˜åˆ¶æ•Œäººä¸»ä½“
                if (this.isFlashing) {
                    ctx.fillStyle = '#FFFFFF';
                } else {
                    ctx.fillStyle = this.color;
                }
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // ç»˜åˆ¶æ•Œäººè¾¹æ¡†
                ctx.strokeStyle = '#2C2C54';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // ç»˜åˆ¶ç”Ÿå‘½æ¡ï¼ˆå¦‚æœæœ‰å¤šæ¡å‘½ï¼‰
                if (this.hitPoints > 1) {
                    this.drawHealthBar(ctx);
                }
                
                // ç»˜åˆ¶ç±»å‹å›¾æ ‡
                this.drawTypeIcon(ctx);
                
                // ç»˜åˆ¶é—®é¢˜æ–‡æœ¬
                this.drawQuestionText(ctx);
                
                ctx.restore();
            }

            drawHealthBar(ctx) {
                const barWidth = 30;
                const barHeight = 4;
                const barX = this.x - barWidth / 2;
                const barY = this.y - this.radius - 10;
                
                // èƒŒæ™¯
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // ç”Ÿå‘½å€¼
                const healthWidth = (this.hitPoints / this.maxHitPoints) * barWidth;
                ctx.fillStyle = this.getHealthColor();
                ctx.fillRect(barX, barY, healthWidth, barHeight);
            }

            getHealthColor() {
                const ratio = this.hitPoints / this.maxHitPoints;
                if (ratio > 0.7) return '#4ECDC4';
                if (ratio > 0.3) return '#FFE66D';
                return '#FF6B6B';
            }

            drawTypeIcon(ctx) {
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const icons = {
                    'spelling': 'âœï¸',
                    'fillBlank': 'ğŸ“',
                    'synonym': 'ğŸ”„',
                    'grammar': 'âš¡'
                };
                
                ctx.fillText(icons[this.type] || 'â“', this.x, this.y);
            }

            drawQuestionText(ctx) {
                ctx.fillStyle = '#2C2C54';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                
                // ç®€åŒ–çš„é¢˜ç›®æ˜¾ç¤º
                const displayText = this.getDisplayText();
                const lines = this.wrapText(ctx, displayText, this.radius * 1.8);
                
                lines.forEach((line, index) => {
                    ctx.fillText(line, this.x, this.y + this.radius + 5 + index * 14);
                });
            }

            getDisplayText() {
                switch (this.type) {
                    case 'spelling':
                        return `æ‹¼å†™: ${this.question.displayText || this.question.wrongSpelling}`;
                    case 'fillBlank':
                        return `å¡«ç©º: ${this.question.sentence}`;
                    case 'synonym':
                        return `åŒä¹‰è¯: ${this.question.word}`;
                    case 'grammar':
                        return `è¯­æ³•: ${this.question.sentence.substring(0, 20)}...`;
                    default:
                        return this.question.text.substring(0, 25);
                }
            }

            wrapText(ctx, text, maxWidth) {
                const words = text.split(' ');
                const lines = [];
                let currentLine = words[0];

                for (let i = 1; i < words.length; i++) {
                    const word = words[i];
                    const width = ctx.measureText(currentLine + " " + word).width;
                    if (width < maxWidth) {
                        currentLine += " " + word;
                    } else {
                        lines.push(currentLine);
                        currentLine = word;
                    }
                }
                lines.push(currentLine);
                return lines;
            }

            takeDamage(amount = 1) {
                this.hitPoints -= amount;
                this.effectTimer = 0.3; // å—ä¼¤é—ªçƒæ•ˆæœ
                return this.hitPoints <= 0;
            }

            setSpeedMultiplier(multiplier) {
                this.speed *= multiplier;
            }

            // ç‰¹æ®Šæ•Œäººè¡Œä¸º
            activateSpecialBehavior() {
                switch (this.type) {
                    case 'spelling':
                        // æ‹¼å†™æ•Œäººä¼šåˆ†è£‚
                        this.speed *= 0.7;
                        break;
                    case 'grammar':
                        // è¯­æ³•æ•Œäººæ›´è€æ‰“
                        this.hitPoints = 3;
                        this.maxHitPoints = 3;
                        break;
                }
            }
        }

        // ç²’å­æ•ˆæœç±»
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.radius = Math.random() * 3 + 1;
                this.color = color;
                this.alpha = 1;
                this.life = 1.0;
                this.decay = 0.02 + Math.random() * 0.02;
                this.text = null;
            }

            update(deltaTime) {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.1; // é‡åŠ›
                this.life -= this.decay;
                this.alpha = this.life;
            }

            draw(ctx) {
                if (this.text) {
                    // ç»˜åˆ¶æ–‡å­—ç²’å­
                    ctx.save();
                    ctx.globalAlpha = this.alpha;
                    ctx.fillStyle = this.color;
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.text, this.x, this.y);
                    ctx.restore();
                } else {
                    // ç»˜åˆ¶åœ†å½¢ç²’å­
                    ctx.save();
                    ctx.globalAlpha = this.alpha;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
        }

        // é¢˜ç›®ç®¡ç†ç³»ç»Ÿ
        class QuestionManager {
            static generateQuestion(difficulty = 'medium') {
                const questionTypes = ['spelling', 'fillBlank', 'synonym', 'grammar'];
                const weights = this.getWeightsByDifficulty(difficulty);
                
                const type = this.getWeightedRandomType(questionTypes, weights);
                
                let question;
                let attempts = 0;
                const maxAttempts = 5;
                
                // å°è¯•ç”Ÿæˆæœ‰æ•ˆçš„é¢˜ç›®
                do {
                    switch (type) {
                        case 'spelling':
                            question = this.generateSpellingQuestion(difficulty);
                            break;
                        case 'fillBlank':
                            question = this.generateFillBlankQuestion(difficulty);
                            break;
                        case 'synonym':
                            question = this.generateSynonymQuestion(difficulty);
                            break;
                        case 'grammar':
                            question = this.generateGrammarQuestion(difficulty);
                            break;
                        default:
                            question = this.generateSpellingQuestion(difficulty);
                    }
                    attempts++;
                } while (!this.validateQuestion(question) && attempts < maxAttempts);
                
                // å¦‚æœè¿˜æ˜¯æ— æ•ˆï¼Œè¿”å›ä¸€ä¸ªé»˜è®¤çš„æ‹¼å†™é¢˜
                if (!this.validateQuestion(question)) {
                    console.warn('æ— æ³•ç”Ÿæˆæœ‰æ•ˆé¢˜ç›®ï¼Œè¿”å›é»˜è®¤é¢˜ç›®');
                    question = this.generateSpellingQuestion('easy');
                }
                
                return question;
            }

            // æ ¹æ®éš¾åº¦è·å–æƒé‡
            static getWeightsByDifficulty(difficulty) {
                const weights = {
                    easy: [0.4, 0.3, 0.2, 0.1],      // æ›´å¤šæ‹¼å†™é¢˜
                    medium: [0.3, 0.3, 0.2, 0.2],    // å¹³è¡¡åˆ†å¸ƒ
                    hard: [0.2, 0.25, 0.25, 0.3]     // æ›´å¤šè¯­æ³•é¢˜
                };
                return weights[difficulty] || weights.medium;
            }

            // åŠ æƒéšæœºé€‰æ‹©é¢˜ç›®ç±»å‹
            static getWeightedRandomType(types, weights) {
                const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
                let random = Math.random() * totalWeight;
                
                for (let i = 0; i < types.length; i++) {
                    random -= weights[i];
                    if (random <= 0) {
                        return types[i];
                    }
                }
                return types[0];
            }

            // ç”Ÿæˆæ‹¼å†™é¢˜ç›®
            static generateSpellingQuestion(difficulty) {
                const wordPools = {
                    easy: [
                        { word: "receive", wrong: "recieve" },
                        { word: "separate", wrong: "seperate" },
                        { word: "definitely", wrong: "definately" },
                        { word: "accommodation", wrong: "acommodation" },
                        { word: "necessary", wrong: "neccessary" },
                        { word: "government", wrong: "goverment" },
                        { word: "environment", wrong: "enviroment" },
                        { word: "library", wrong: "libary" }
                    ],
                    medium: [
                        { word: "embarrass", wrong: "embarass" },
                        { word: "millennium", wrong: "millenium" },
                        { word: "maintenance", wrong: "maintainance" },
                        { word: "conscience", wrong: "concience" },
                        { word: "rhythm", wrong: "rythm" },
                        { word: "privilege", wrong: "priviledge" },
                        { word: "calendar", wrong: "calender" }
                    ],
                    hard: [
                        { word: "pneumonia", wrong: "neumonia" },
                        { word: "psychology", wrong: "sycology" },
                        { word: "mnemonic", wrong: "nemonik" },
                        { word: "pharaoh", wrong: "farao" },
                        { word: "dilemma", wrong: "dilema" },
                        { word: "minuscule", wrong: "miniscule" }
                    ]
                };

                const pool = wordPools[difficulty] || wordPools.medium;
                const item = pool[Math.floor(Math.random() * pool.length)];
                
                // ç”Ÿæˆå¹²æ‰°é¡¹
                const options = this.generateSpellingOptions(item.word, item.wrong, pool);
                
                return {
                    type: 'spelling',
                    text: `æ‰¾å‡ºæ­£ç¡®çš„å•è¯æ‹¼å†™ï¼š`,
                    displayText: item.wrong,
                    wrongSpelling: item.wrong,
                    options: options,
                    correctAnswer: item.word,
                    difficulty: difficulty
                };
            }

            // ç”Ÿæˆæ‹¼å†™é€‰é¡¹
            static generateSpellingOptions(correct, wrong, pool) {
                const options = [correct, wrong];
                
                // æ·»åŠ å…¶ä»–å¹²æ‰°é¡¹
                while (options.length < 4) {
                    const randomWord = pool[Math.floor(Math.random() * pool.length)].word;
                    if (!options.includes(randomWord)) {
                        options.push(randomWord);
                    }
                }
                
                return this.shuffleArray(options);
            }

            // ç”Ÿæˆå¡«ç©ºé¢˜
            static generateFillBlankQuestion(difficulty) {
                const sentencePools = {
                    easy: [
                        { sentence: "I ____ to school every day.", correct: "go", options: ["go", "went", "have gone", "going"] },
                        { sentence: "She ____ reading a book now.", correct: "is", options: ["is", "are", "am", "be"] },
                        { sentence: "They ____ playing football yesterday.", correct: "were", options: ["were", "was", "are", "is"] },
                        { sentence: "We ____ dinner at 7 PM every day.", correct: "eat", options: ["eat", "ate", "eaten", "eating"] }
                    ],
                    medium: [
                        { sentence: "If I ____ you, I would study harder.", correct: "were", options: ["were", "was", "am", "be"] },
                        { sentence: "By next year, I ____ English for five years.", correct: "will have studied", options: ["will have studied", "will study", "studied", "have studied"] },
                        { sentence: "He wishes he ____ more time to travel.", correct: "had", options: ["had", "has", "have", "will have"] }
                    ],
                    hard: [
                        { sentence: "Not only ____ late, but he also forgot the documents.", correct: "was he", options: ["was he", "he was", "did he be", "he were"] },
                        { sentence: "Had I known earlier, I ____ differently.", correct: "would have acted", options: ["would have acted", "would act", "acted", "will act"] },
                        { sentence: "Such ____ the case, we had to reconsider our position.", correct: "being", options: ["being", "was", "is", "to be"] }
                    ]
                };

                const pool = sentencePools[difficulty] || sentencePools.medium;
                const item = pool[Math.floor(Math.random() * pool.length)];
                
                return {
                    type: 'fillBlank',
                    text: `é€‰æ‹©æ­£ç¡®çš„å•è¯å®Œæˆå¥å­ï¼š\n"${item.sentence}"`,
                    sentence: item.sentence,
                    options: this.shuffleArray([...item.options]),
                    correctAnswer: item.correct,
                    difficulty: difficulty
                };
            }

            // ç”ŸæˆåŒä¹‰è¯é¢˜
            static generateSynonymQuestion(difficulty) {
                const synonymPools = {
                    easy: [
                        { word: "happy", correct: "joyful", options: ["joyful", "sad", "angry", "tired"] },
                        { word: "big", correct: "large", options: ["large", "small", "tiny", "little"] },
                        { word: "smart", correct: "intelligent", options: ["intelligent", "stupid", "slow", "lazy"] },
                        { word: "beautiful", correct: "pretty", options: ["pretty", "ugly", "plain", "ordinary"] }
                    ],
                    medium: [
                        { word: "difficult", correct: "challenging", options: ["challenging", "easy", "simple", "basic"] },
                        { word: "important", correct: "significant", options: ["significant", "unimportant", "trivial", "minor"] },
                        { word: "quick", correct: "rapid", options: ["rapid", "slow", "sluggish", "delayed"] }
                    ],
                    hard: [
                        { word: "ambiguous", correct: "vague", options: ["vague", "clear", "obvious", "definite"] },
                        { word: "benevolent", correct: "kind", options: ["kind", "cruel", "mean", "selfish"] },
                        { word: "concur", correct: "agree", options: ["agree", "disagree", "oppose", "reject"] }
                    ]
                };

                const pool = synonymPools[difficulty] || synonymPools.medium;
                const item = pool[Math.floor(Math.random() * pool.length)];
                
                return {
                    type: 'synonym',
                    text: `é€‰æ‹© "${item.word}" çš„åŒä¹‰è¯ï¼š`,
                    word: item.word,
                    options: this.shuffleArray([...item.options]),
                    correctAnswer: item.correct,
                    difficulty: difficulty
                };
            }

            // ç”Ÿæˆè¯­æ³•é¢˜
            static generateGrammarQuestion(difficulty) {
                const grammarPools = {
                    easy: [
                        { 
                            sentence: "She don't like coffee.", 
                            corrected: "She doesn't like coffee.",
                            explanation: "ç¬¬ä¸‰äººç§°å•æ•°è¦ç”¨ doesn't"
                        },
                        { 
                            sentence: "I have two cat.", 
                            corrected: "I have two cats.",
                            explanation: "å¤æ•°åè¯è¦åŠ -s"
                        }
                    ],
                    medium: [
                        { 
                            sentence: "Between you and I, this is wrong.", 
                            corrected: "Between you and me, this is wrong.",
                            explanation: "ä»‹è¯åé¢è¦ç”¨å®¾æ ¼ me"
                        },
                        { 
                            sentence: "Neither of the students have finished.", 
                            corrected: "Neither of the students has finished.",
                            explanation: "Neither æ¥å•æ•°åŠ¨è¯"
                        }
                    ],
                    hard: [
                        { 
                            sentence: "The team are winning their game.", 
                            corrected: "The team is winning its game.",
                            explanation: "é›†ä½“åè¯ team ä½œä¸ºå•æ•°çœ‹å¾…"
                        },
                        { 
                            sentence: "If I was you, I would go.", 
                            corrected: "If I were you, I would go.",
                            explanation: "è™šæ‹Ÿè¯­æ°”è¦ç”¨ were"
                        }
                    ]
                };

                const pool = grammarPools[difficulty] || grammarPools.medium;
                const item = pool[Math.floor(Math.random() * pool.length)];
                
                // ç”Ÿæˆé”™è¯¯é€‰é¡¹
                const options = this.generateGrammarOptions(item.corrected, item.sentence);
                
                return {
                    type: 'grammar',
                    text: `é€‰æ‹©æ­£ç¡®çš„å¥å­ï¼š`,
                    sentence: item.sentence,
                    options: options,
                    correctAnswer: item.corrected,
                    explanation: item.explanation,
                    difficulty: difficulty
                };
            }

            // ç”Ÿæˆè¯­æ³•é€‰é¡¹
            static generateGrammarOptions(correct, wrong) {
                const options = [correct, wrong];
                
                // æ·»åŠ å…¶ä»–è¯­æ³•å˜ä½“ä½œä¸ºå¹²æ‰°é¡¹
                const variations = [
                    correct.replace(" doesn't ", " don't "),
                    correct.replace(" has ", " have "),
                    correct.replace(" is ", " are "),
                    correct.replace(" were ", " was ")
                ];
                
                for (const variation of variations) {
                    if (variation !== correct && !options.includes(variation) && options.length < 4) {
                        options.push(variation);
                    }
                }
                
                // å¦‚æœé€‰é¡¹ä¸å¤Ÿï¼Œæ·»åŠ ä¸€äº›é€šç”¨å¹²æ‰°é¡¹ï¼ˆä¿®å¤ç©ºé€‰é¡¹é—®é¢˜ï¼‰
                const fallbackOptions = [
                    "This is correct.",
                    "That is right.",
                    "It should be this.",
                    "The correct one."
                ];
                
                while (options.length < 4) {
                    const randomOption = fallbackOptions[options.length % fallbackOptions.length];
                    if (!options.includes(randomOption)) {
                        options.push(randomOption);
                    } else {
                        // å¦‚æœè¿˜æ˜¯é‡å¤ï¼Œæ·»åŠ ä¸€ä¸ªå¸¦æ•°å­—çš„é€‰é¡¹
                        const numberedOption = `Option ${options.length + 1}`;
                        options.push(numberedOption);
                    }
                    
                    // é˜²æ­¢æ— é™å¾ªç¯
                    if (options.length >= 10) break;
                }
                
                return this.shuffleArray(options);
            }

            // æ•°ç»„æ´—ç‰Œ
            static shuffleArray(array) {
                const newArray = [...array];
                for (let i = newArray.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
                }
                return newArray;
            }

            // è·å–é¢˜ç›®ç»Ÿè®¡ä¿¡æ¯
            static getQuestionStats() {
                const stats = JSON.parse(localStorage.getItem('questionStats') || '{}');
                return stats;
            }

            // æ›´æ–°é¢˜ç›®ç»Ÿè®¡
            static updateQuestionStats(questionType, isCorrect) {
                const stats = this.getQuestionStats();
                
                if (!stats[questionType]) {
                    stats[questionType] = { total: 0, correct: 0 };
                }
                
                stats[questionType].total++;
                if (isCorrect) {
                    stats[questionType].correct++;
                }
                
                localStorage.setItem('questionStats', JSON.stringify(stats));
            }

            // è·å–ç”¨æˆ·çš„è–„å¼±ç¯èŠ‚
            static getWeakAreas() {
                const stats = this.getQuestionStats();
                const areas = [];
                
                for (const [type, data] of Object.entries(stats)) {
                    const accuracy = data.correct / data.total;
                    if (accuracy < 0.7) { // æ­£ç¡®ç‡ä½äº70%è§†ä¸ºè–„å¼±ç¯èŠ‚
                        areas.push({
                            type: type,
                            accuracy: accuracy,
                            totalAttempts: data.total
                        });
                    }
                }
                
                return areas.sort((a, b) => a.accuracy - b.accuracy);
            }

            // æ·»åŠ é¢˜ç›®éªŒè¯æ–¹æ³•
            static validateQuestion(question) {
                if (!question) return false;
                if (!question.options || !Array.isArray(question.options)) return false;
                if (question.options.length < 2) return false;
                if (!question.correctAnswer) return false;
                if (!question.options.includes(question.correctAnswer)) return false;
                return true;
            }
        }

        // æ¸¸æˆä¸»ç±»
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.currentScreen = 'menu';
                
                // åŠ¨æ€è·å–æœåŠ¡å™¨åœ°å€ - ä¿®æ”¹ä¸ºç›¸å¯¹è·¯å¾„
                this.baseURL = '';
                
                // æ¸¸æˆçŠ¶æ€
                this.score = 0;
                this.combo = 0;
                this.maxCombo = 0;
                this.lives = 3;
                this.level = 1;
                this.timer = 60;
                this.gameTime = 0;
                this.isPaused = false;
                this.gameOver = false;
                
                // æ¸¸æˆå¯¹è±¡
                this.player = new Player(this.canvas.width / 2, this.canvas.height - 50);
                this.enemies = [];
                this.bullets = [];
                this.particles = [];
                
                // æ¸¸æˆè®¾ç½®
                this.difficulty = 'medium';
                this.enemySpawnRate = 0.02; // æ•Œäººç”Ÿæˆæ¦‚ç‡
                this.gameLoopId = null;
                this.lastTime = 0;
                
                // å½“å‰æ¿€æ´»çš„æ•Œäººï¼ˆéœ€è¦å›ç­”é—®é¢˜çš„æ•Œäººï¼‰
                this.activeEnemy = null;
                
                this.initializeEventListeners();
                this.loadAchievements();
            }

            initializeEventListeners() {
                // èœå•æŒ‰é’® - ä¿®å¤ï¼šç¡®ä¿æŒ‰é’®å­˜åœ¨åå†æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
                const startButton = document.getElementById('startButton');
                const viewAchievements = document.getElementById('viewAchievements');
                const restartButton = document.getElementById('restartButton');
                const menuButton = document.getElementById('menuButton');
                const backToMenu = document.getElementById('backToMenu');
                
                if (startButton) {
                    startButton.addEventListener('click', () => this.startGame());
                    console.log('å¼€å§‹æ¸¸æˆæŒ‰é’®äº‹ä»¶ç»‘å®šæˆåŠŸ');
                } else {
                    console.error('æœªæ‰¾åˆ°å¼€å§‹æ¸¸æˆæŒ‰é’®');
                }
                
                if (viewAchievements) {
                    viewAchievements.addEventListener('click', () => this.showAchievements());
                    console.log('æˆ‘çš„æˆå°±æŒ‰é’®äº‹ä»¶ç»‘å®šæˆåŠŸ');
                } else {
                    console.error('æœªæ‰¾åˆ°æˆ‘çš„æˆå°±æŒ‰é’®');
                }
                
                if (restartButton) {
                    restartButton.addEventListener('click', () => this.restartGame());
                }
                
                if (menuButton) {
                    menuButton.addEventListener('click', () => this.showScreen('menu'));
                }
                
                if (backToMenu) {
                    backToMenu.addEventListener('click', () => this.showScreen('menu'));
                }
                
                // éš¾åº¦é€‰æ‹© - ä¿®å¤äº‹ä»¶ç›‘å¬
                const difficultySelect = document.getElementById('difficultySelect');
                if (difficultySelect) {
                    difficultySelect.addEventListener('change', (e) => {
                        this.difficulty = e.target.value;
                        console.log('éš¾åº¦è®¾ç½®ä¸º:', this.difficulty); // è°ƒè¯•ç”¨
                    });
                    
                    // è®¾ç½®åˆå§‹éš¾åº¦
                    this.difficulty = difficultySelect.value;
                } else {
                    console.warn('æœªæ‰¾åˆ°éš¾åº¦é€‰æ‹©å…ƒç´ ï¼Œä½¿ç”¨é»˜è®¤éš¾åº¦');
                    this.difficulty = 'medium';
                }

                // é”®ç›˜æ§åˆ¶
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
                
                // é¼ æ ‡ç§»åŠ¨æ§åˆ¶ç‚®å°
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                
                // è§¦æ‘¸å±æ”¯æŒ
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    this.canvas.dispatchEvent(mouseEvent);
                });
            }

            async startGame() {
                console.log('å¼€å§‹æ¸¸æˆï¼Œéš¾åº¦:', this.difficulty);
                console.log('æœåŠ¡å™¨åœ°å€:', this.baseURL);
                
                // æ£€æŸ¥è¯æ±‡åº“æ˜¯å¦ä¸ºç©º
                try {
                    const isEmpty = await this.checkVocabularyEmpty();
                    if (isEmpty) {
                        alert('è¯æ±‡åº“ä¸ºç©ºï¼è¯·å…ˆå¯¼å…¥è¯æ±‡æ•°æ®å†å¼€å§‹æ¸¸æˆã€‚');
                        this.showScreen('vocabulary');
                        return;
                    }
                } catch (error) {
                    console.error('æ£€æŸ¥è¯æ±‡åº“å¤±è´¥:', error);
                    alert('æ£€æŸ¥è¯æ±‡åº“å¤±è´¥ï¼Œè¯·ç¡®ä¿æœåŠ¡å™¨æ­£å¸¸è¿è¡Œ');
                    return;
                }
                
                // éªŒè¯éš¾åº¦è®¾ç½®
                const validDifficulties = ['easy', 'medium', 'hard'];
                if (!validDifficulties.includes(this.difficulty)) {
                    console.warn('æ— æ•ˆéš¾åº¦ï¼Œé‡ç½®ä¸ºä¸­ç­‰éš¾åº¦');
                    this.difficulty = 'medium';
                }
                
                // é‡ç½®æ¸¸æˆå‰å…ˆæ¸…é™¤æ‰€æœ‰çŠ¶æ€
                if (this.gameLoopId) {
                    cancelAnimationFrame(this.gameLoopId);
                }
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                
                this.resetGame();
                this.showScreen('game');
                this.lastTime = performance.now();
                this.gameLoopId = requestAnimationFrame((time) => this.gameLoop(time));
                
                // å¼€å§‹è®¡æ—¶å™¨
                this.timerInterval = setInterval(() => {
                    if (!this.isPaused && !this.gameOver) {
                        this.timer--;
                        this.updateUI();
                        
                        if (this.timer <= 0) {
                            this.levelUp();
                        }
                    }
                }, 1000);
            }

            /**
             * æ£€æŸ¥è¯æ±‡åº“æ˜¯å¦ä¸ºç©º
             */
            async checkVocabularyEmpty() {
                try {
                    // ä¿®æ”¹APIè·¯å¾„ - ä½¿ç”¨ç›¸å¯¹è·¯å¾„
                    const response = await fetch(`/api/game/vocabulary/vocabulary-statistics`);
                    const result = await response.json();
                    
                    if (result.success) {
                        const totalWords = result.data.total_words?.[0]?.count || 0;
                        return totalWords === 0;
                    } else {
                        throw new Error(result.message);
                    }
                } catch (error) {
                    console.error('æ£€æŸ¥è¯æ±‡åº“å¤±è´¥:', error);
                    throw error;
                }
            }

            /**
             * ä»æœåŠ¡å™¨ç”Ÿæˆæ•Œäººé¢˜ç›®
             */
            async generateEnemyQuestion() {
                try {
                    // ä¿®æ”¹APIè·¯å¾„ - ä½¿ç”¨ç›¸å¯¹è·¯å¾„
                    const response = await fetch(
                        `/api/game/questions?difficulty=${this.difficulty}&limit=1`
                    );
                    
                    if (response.ok) {
                        const questions = await response.json();
                        if (questions.length > 0) {
                            return questions[0];
                        }
                    }
                } catch (error) {
                    console.warn('ä»æœåŠ¡å™¨è·å–é¢˜ç›®å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°é¢˜ç›®:', error);
                }
                
                // å›é€€åˆ°æœ¬åœ°ç”Ÿæˆçš„é¢˜ç›®
                return QuestionManager.generateQuestion(this.difficulty);
            }

            gameLoop(currentTime) {
                if (this.gameOver) return;
                
                const deltaTime = (currentTime - this.lastTime) / 1000;
                this.lastTime = currentTime;
                this.gameTime += deltaTime;

                if (!this.isPaused) {
                    this.update(deltaTime);
                    this.render();
                }
                
                this.gameLoopId = requestAnimationFrame((time) => this.gameLoop(time));
            }

            update(deltaTime) {
                // ç”Ÿæˆæ•Œäºº
                this.spawnEnemies();
                
                // æ›´æ–°æ•Œäºº
                this.updateEnemies(deltaTime);
                
                // æ›´æ–°å­å¼¹
                this.updateBullets(deltaTime);
                
                // æ›´æ–°ç²’å­æ•ˆæœ
                this.updateParticles(deltaTime);
                
                // æ£€æµ‹ç¢°æ’
                this.checkCollisions();
                
                // æ£€æŸ¥æ¸¸æˆç»“æŸæ¡ä»¶
                this.checkGameOver();
            }

            spawnEnemies() {
                const baseRates = {
                    easy: 0.015,
                    medium: 0.02,
                    hard: 0.025
                };
                
                const baseRate = baseRates[this.difficulty] || 0.02;
                const levelMultiplier = 1 + (this.level - 1) * 0.15; // é™ä½ç­‰çº§å¢é•¿ç³»æ•°
                const currentRate = baseRate * levelMultiplier;
                
                // é™åˆ¶æœ€å¤§æ•Œäººæ•°é‡å’Œç”Ÿæˆæ¦‚ç‡
                const maxEnemies = {
                    easy: 8,
                    medium: 10,
                    hard: 12
                };
                
                const currentMaxEnemies = maxEnemies[this.difficulty] || 10;
                
                if (Math.random() < currentRate && this.enemies.length < currentMaxEnemies) {
                    // ä½¿ç”¨å¼‚æ­¥æ–¹å¼ç”Ÿæˆæ•Œäºº
                    this.generateEnemyQuestion().then(question => {
                        if (question && question.options && question.options.length >= 2) {
                            const enemy = new Enemy(question);
                            this.enemies.push(enemy);
                        } else {
                            console.warn('ç”Ÿæˆçš„é¢˜ç›®æ— æ•ˆï¼Œè·³è¿‡æ•Œäººåˆ›å»º');
                        }
                    }).catch(error => {
                        console.error('ç”Ÿæˆæ•Œäººé¢˜ç›®å¤±è´¥:', error);
                        // å¦‚æœç”Ÿæˆé¢˜ç›®å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°é¢˜ç›®
                        try {
                            const question = QuestionManager.generateQuestion(this.difficulty);
                            if (question && question.options && question.options.length >= 2) {
                                const enemy = new Enemy(question);
                                this.enemies.push(enemy);
                            }
                        } catch (fallbackError) {
                            console.error('å¤‡ç”¨é¢˜ç›®ç”Ÿæˆä¹Ÿå¤±è´¥:', fallbackError);
                        }
                    });
                }
            }

            updateEnemies(deltaTime) {
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    enemy.update(deltaTime);
                    
                    // æ£€æŸ¥æ•Œäººæ˜¯å¦åˆ°è¾¾åº•éƒ¨
                    if (enemy.y > this.canvas.height) {
                        this.lives--;
                        this.enemies.splice(i, 1);
                        this.updateUI();
                        this.createParticleEffect(enemy.x, enemy.y, '#ff0000');
                    }
                }
            }

            updateBullets(deltaTime) {
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    bullet.update(deltaTime);
                    
                    // ç§»é™¤è¶…å‡ºå±å¹•çš„å­å¼¹
                    if (bullet.y < 0 || bullet.x < 0 || bullet.x > this.canvas.width) {
                        this.bullets.splice(i, 1);
                    }
                }
            }

            updateParticles(deltaTime) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    particle.update(deltaTime);
                    
                    if (particle.alpha <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            }

            checkCollisions() {
                // å­å¼¹ä¸æ•Œäººç¢°æ’æ£€æµ‹
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    
                    for (let j = this.enemies.length - 1; j >= 0; j--) {
                        const enemy = this.enemies[j];
                        
                        if (this.isColliding(bullet, enemy)) {
                            // å‡»ä¸­æ•Œäººï¼Œæ˜¾ç¤ºé—®é¢˜
                            this.showQuestion(enemy);
                            this.bullets.splice(i, 1);
                            break;
                        }
                    }
                }
            }

            isColliding(obj1, obj2) {
                const dx = obj1.x - obj2.x;
                const dy = obj1.y - obj2.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < (obj1.radius + obj2.radius);
            }

            showQuestion(enemy) {
                if (!enemy || !enemy.question) {
                    console.error('æ— æ•ˆçš„æ•Œäººæˆ–é¢˜ç›®');
                    this.isPaused = false;
                    return;
                }
                
                try {
                    this.activeEnemy = enemy;
                    this.isPaused = true;
                    
                    const questionText = document.getElementById('questionText');
                    const answerButtons = document.getElementById('answerButtons');
                    const answerContainer = document.getElementById('answerContainer');
                    
                    if (!questionText || !answerButtons || !answerContainer) {
                        console.error('æœªæ‰¾åˆ°ç­”é¢˜ç•Œé¢å…ƒç´ ');
                        this.isPaused = false;
                        return;
                    }
                    
                    questionText.textContent = enemy.question.text || 'è¯·é€‰æ‹©æ­£ç¡®ç­”æ¡ˆï¼š';
                    answerButtons.innerHTML = '';
                    
                    // åˆ›å»ºç­”æ¡ˆæŒ‰é’®
                    if (enemy.question.options && Array.isArray(enemy.question.options)) {
                        enemy.question.options.forEach((option, index) => {
                            const button = document.createElement('button');
                            button.textContent = option || `é€‰é¡¹ ${index + 1}`;
                            button.className = 'answer-btn';
                            button.addEventListener('click', () => this.handleAnswer(option));
                            answerButtons.appendChild(button);
                        });
                    } else {
                        console.error('é¢˜ç›®é€‰é¡¹æ— æ•ˆ');
                        this.isPaused = false;
                        return;
                    }
                    
                    answerContainer.classList.remove('hidden');
                } catch (error) {
                    console.error('æ˜¾ç¤ºé¢˜ç›®æ—¶å‡ºé”™:', error);
                    this.isPaused = false;
                }
            }

            handleAnswer(selectedAnswer) {
                const answerContainer = document.getElementById('answerContainer');
                answerContainer.classList.add('hidden');
                this.isPaused = false;
                
                if (this.activeEnemy && this.activeEnemy.question.correctAnswer === selectedAnswer) {
                    // å›ç­”æ­£ç¡®
                    this.combo++;
                    this.maxCombo = Math.max(this.maxCombo, this.combo);
                    const points = 10 * this.combo; // è¿å‡»åŠ åˆ†
                    this.score += points;
                    
                    // ç§»é™¤æ•Œäººå¹¶åˆ›å»ºç‰¹æ•ˆ
                    const enemyIndex = this.enemies.indexOf(this.activeEnemy);
                    if (enemyIndex > -1) {
                        this.createParticleEffect(this.activeEnemy.x, this.activeEnemy.y, '#00ff00');
                        this.enemies.splice(enemyIndex, 1);
                    }
                    
                    // æ˜¾ç¤ºå¾—åˆ†é£˜å­—
                    this.createScorePopup(this.activeEnemy.x, this.activeEnemy.y, `+${points}`);
                    
                } else {
                    // å›ç­”é”™è¯¯
                    this.combo = 0;
                    this.createParticleEffect(this.activeEnemy.x, this.activeEnemy.y, '#ff6b6b');
                }
                
                this.activeEnemy = null;
                this.updateUI();
                this.checkAchievements();
            }

            createParticleEffect(x, y, color) {
                for (let i = 0; i < 15; i++) {
                    this.particles.push(new Particle(x, y, color));
                }
            }

            createScorePopup(x, y, text) {
                const particle = new Particle(x, y, '#ffff00');
                particle.vx = (Math.random() - 0.5) * 2;
                particle.vy = -2;
                particle.text = text;
                particle.life = 1.0;
                this.particles.push(particle);
            }

            handleKeyDown(e) {
                if (this.currentScreen !== 'game') return;
                
                if (e.code === 'Space' && !this.isPaused) {
                    this.shoot();
                } else if (e.code === 'Escape') {
                    this.isPaused = !this.isPaused;
                }
            }

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                this.player.x = Math.max(20, Math.min(this.canvas.width - 20, mouseX));
            }

            shoot() {
                const bullet = {
                    x: this.player.x,
                    y: this.player.y - 20,
                    radius: 4, // ä¿®å¤ï¼šä½¿ç”¨å†’å·è€Œä¸æ˜¯ç­‰å·
                    speed: 8,
                    color: '#ffff00',
                    update: function(deltaTime) {
                        this.y -= this.speed;
                    },
                    draw: function(ctx) {
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // å­å¼¹æ‹–å°¾æ•ˆæœ
                        ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y + 5, this.radius * 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                };
                
                this.bullets.push(bullet);
            }

            render() {
                // æ¸…ç©ºç”»å¸ƒ
                this.ctx.fillStyle = '#1a1a2e';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ç»˜åˆ¶èƒŒæ™¯ç½‘æ ¼
                this.drawGrid();
                
                // ç»˜åˆ¶æ‰€æœ‰æ¸¸æˆå¯¹è±¡
                this.particles.forEach(particle => particle.draw(this.ctx));
                this.enemies.forEach(enemy => enemy.draw(this.ctx));
                this.bullets.forEach(bullet => bullet.draw(this.ctx));
                this.player.draw(this.ctx);
                
                // ç»˜åˆ¶è¿å‡»ç‰¹æ•ˆ
                if (this.combo >= 3) {
                    this.drawComboEffect();
                }
            }

            drawGrid() {
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                this.ctx.lineWidth = 1;
                
                // å‚ç›´çº¿
                for (let x = 0; x <= this.canvas.width; x += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                // æ°´å¹³çº¿
                for (let y = 0; y <= this.canvas.height; y += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }

            drawComboEffect() {
                const intensity = Math.min(this.combo / 10, 1);
                this.ctx.strokeStyle = `rgba(255, 215, 0, ${intensity * 0.5})`;
                this.ctx.lineWidth = 3 + intensity * 2;
                this.ctx.strokeRect(0, 0, this.canvas.width, this.canvas.height);
            }

            levelUp() {
                this.level++;
                this.timer = 60;
                this.enemySpawnRate *= 1.2; // å¢åŠ æ•Œäººç”Ÿæˆç‡
                
                // ç­‰çº§æå‡ç‰¹æ•ˆ
                this.createParticleEffect(this.canvas.width / 2, this.canvas.height / 2, '#ff00ff');
                this.createScorePopup(this.canvas.width / 2, this.canvas.height / 2, `Level ${this.level}!`);
            }

            checkGameOver() {
                if (this.lives <= 0) {
                    this.endGame();
                }
            }

            endGame() {
                this.gameOver = true;
                cancelAnimationFrame(this.gameLoopId);
                clearInterval(this.timerInterval);
                
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('maxCombo').textContent = this.maxCombo;
                this.showScreen('gameOver');
                
                this.saveAchievements();
            }

            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('combo').textContent = this.combo;
                document.getElementById('lives').textContent = this.lives;
                document.getElementById('level').textContent = this.level;
                document.getElementById('timer').textContent = this.timer;
            }

            showScreen(screenName) {
                this.currentScreen = screenName;
                
                // éšè—æ‰€æœ‰å±å¹•
                document.querySelectorAll('.screen').forEach(screen => {
                    screen.classList.add('hidden');
                });
                
                // æ˜¾ç¤ºç›®æ ‡å±å¹•
                document.getElementById(screenName + 'Screen').classList.remove('hidden');
            }

            resetGame() {
                this.score = 0;
                this.combo = 0;
                this.maxCombo = 0;
                this.lives = 3;
                this.level = 1;
                this.timer = 60;
                this.gameTime = 0;
                this.isPaused = false;
                this.gameOver = false;
                
                this.enemies = [];
                this.bullets = [];
                this.particles = [];
                this.activeEnemy = null;
                
                this.enemySpawnRate = 0.02;
                this.updateUI();
            }

            restartGame() {
                this.resetGame();
                this.startGame();
            }

            // æˆå°±ç³»ç»Ÿ
            loadAchievements() {
                this.achievements = JSON.parse(localStorage.getItem('wordBusterAchievements') || '{}');
            }

            saveAchievements() {
                localStorage.setItem('wordBusterAchievements', JSON.stringify(this.achievements));
            }

            checkAchievements() {
                const newAchievements = [];
                
                if (this.score >= 1000 && !this.achievements.score1000) {
                    this.achievements.score1000 = true;
                    newAchievements.push('å¾—åˆ†è¾¾äººï¼šè·å¾—1000åˆ†');
                }
                
                if (this.maxCombo >= 10 && !this.achievements.combo10) {
                    this.achievements.combo10 = true;
                    newAchievements.push('è¿å‡»å¤§å¸ˆï¼šè¾¾æˆ10è¿å‡»');
                }
                
                if (this.level >= 5 && !this.achievements.level5) {
                    this.achievements.level5 = true;
                    newAchievements.push('è¿›é˜¶é«˜æ‰‹ï¼šè¾¾åˆ°ç¬¬5å…³');
                }
                
                if (newAchievements.length > 0) {
                    this.showAchievementPopup(newAchievements);
                    this.saveAchievements();
                }
            }

            showAchievementPopup(achievements) {
                achievements.forEach(achievement => {
                    console.log('æˆå°±è§£é”ï¼š', achievement);
                    // è¿™é‡Œå¯ä»¥æ·»åŠ æˆå°±å¼¹çª—æ•ˆæœ
                });
            }

            showAchievements() {
                this.showScreen('achievements');
                const list = document.getElementById('achievementsList');
                list.innerHTML = '';
                
                const allAchievements = [
                    { id: 'score1000', name: 'å¾—åˆ†è¾¾äºº', desc: 'è·å¾—1000åˆ†' },
                    { id: 'combo10', name: 'è¿å‡»å¤§å¸ˆ', desc: 'è¾¾æˆ10è¿å‡»' },
                    { id: 'level5', name: 'è¿›é˜¶é«˜æ‰‹', desc: 'è¾¾åˆ°ç¬¬5å…³' }
                ];
                
                allAchievements.forEach(ach => {
                    const div = document.createElement('div');
                    div.className = `achievement-item ${this.achievements[ach.id] ? 'unlocked' : 'locked'}`;
                    div.innerHTML = `
                        <h3>${ach.name}</h3>
                        <p>${ach.desc}</p>
                        <span>${this.achievements[ach.id] ? 'âœ“ å·²è§£é”' : 'ğŸ”’ æœªè§£é”'}</span>
                    `;
                    list.appendChild(div);
                });
            }
        }

        // åˆå§‹åŒ–æ¸¸æˆ
        document.addEventListener('DOMContentLoaded', () => {
            window.game = new Game();
        });
    </script>
</body>
</html>